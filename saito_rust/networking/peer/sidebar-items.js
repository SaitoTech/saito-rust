initSidebarItems({"fn":[["build_request_block_response",""],["build_send_blockchain_message",""],["build_serialized_challenge",""],["handle_inbound_peer_connection","spawns a task to read messages from the socket of inbound peers."],["send_message_to_socket","Sends an APIMessage to a socket connection. Since Outbound and Inbound peers Streams(Sinks) are not unified into a single Trait yet, we must check both dbs to find out which sort of sink this peer is using and send the message through the appopriate stream."],["socket_handshake_verify",""],["socket_receive_transaction",""],["socket_send_block_header",""]],"struct":[["INBOUND_PEER_CONNECTIONS_GLOBAL",""],["InboundPeer","An inbound Peer. This holds a Stream(Sender/Sink) for a peer which has initialized a connection to us via /wsopen."],["OUTBOUND_PEER_CONNECTIONS_GLOBAL",""],["OutboundPeer","An outbound Peer. This holds a Stream(Sender/Sink) for a peer which we have connected to via /wsopen. TODO: Unify InboundPeer and OutboundPeer into a single trait and perhaps integrate it into SaitoPeer. This has proven to be a very difficult task because of ownership loops that make it very tricky to interact with a peer by reading messages from a socket which is inside the peer. This is why we have a separate structure to hold the sockets vs the rest of the peer data. It may be easy to at least unify Inbound and Outbound into a single Trait though and merge InboundPeersDB and OutboundPeersDB"],["PEERS_DB_GLOBAL",""],["PEERS_REQUEST_RESPONSES_GLOBAL",""],["PEERS_REQUEST_WAKERS_GLOBAL",""],["PeerFlags","Flags for Peer state."],["PeerRequest",""],["PeerSetting","Settings for remote Peers"],["SaitoPeer","A Peer. i.e. another node in the network."]],"type":[["InboundPeersDB",""],["OutboundPeersDB",""],["PeersDB",""],["RequestResponses",""],["RequestWakers",""]]});